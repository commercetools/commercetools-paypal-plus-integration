// script to build/push docker images.
// The script setup, opposite to most of other gradle plugins, is quite obfuscated,
// hence requires dedicated `buildscript` block and special classes imports.
// see https://github.com/bmuschko/gradle-docker-plugin#remote-api-plugin
// http://bmuschko.com/blog/dockerized-spring-boot-app/
// Also, we don't use custom createDockerfile task in favor of static `docker-build/Dockerfile`,
// which could be reused, for instance, for local native docker builds.
// This could be changed in the future if we really need custom runtime flexible Dockerfile managing

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath "com.bmuschko:gradle-docker-plugin:$dockerPackageVersion"
    }
}

apply plugin: com.bmuschko.gradle.docker.DockerRemoteApiPlugin

apply from: "$rootDir/gradle/util.gradle"


import com.bmuschko.gradle.docker.tasks.container.*
import com.bmuschko.gradle.docker.tasks.container.extras.DockerWaitHealthyContainer
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerPullImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage

// project specific settings:
final dockerContextDir = file('.')
final dockerfileFile = file('docker-build/Dockerfile')
final dockerRepository = 'commercetoolsps/commercetools-paypal-plus-integration'
final dockerUserProperty = 'docker.username'
final dockerPassProperty = 'docker.password'

task buildDockerImage(type: DockerBuildImage) {
    dependsOn assemble

    inputDir = dockerContextDir
    dockerFile = dockerfileFile

    tag = "$dockerRepository:$project.version"
}

task pushDockerImage(type: DockerPushImage) {
    conventionMapping.imageName = { buildDockerImage.getTag() }

    // because the push task could be skipped (in local builds) we avoid credentials reading in default configuration setup,
    // like here: https://github.com/bmuschko/gradle-docker-plugin#extension-examples
    // Instead read/verify them only when the push task is called
    doFirst {
        docker.registryCredentials {
            username = getConfigurationPropertyOrThrow(dockerUserProperty)
            password = getConfigurationPropertyOrThrow(dockerPassProperty)
        }
    }
}

// task from http://bmuschko.com/blog/docker-integration-testing/ article

final dockerTagVersion = project.version // use the same docker image tag, as current build version

task pullImage(type: DockerPullImage) {
    // NOTE: pulling image could be skipped in the local test, just build and run it
    repository = dockerRepository
    tag = dockerTagVersion
}

task createContainer(type: DockerCreateContainer) {
    targetImageId { pullImage.getImageId() }
    portBindings = ['8080:8080'] // default Spring-boot port
}

task startContainer(type: DockerStartContainer) {
    // if this task fails when containers is already started  or the port is already binded
    // > Bind for 0.0.0.0:8080 failed: port is already allocated
    // then kill the local docker container for that port manually:
    // $ docker ps
    // $ docker kill <container_id>

    dependsOn createContainer
    targetContainerId { createContainer.getContainerId() }
}

task startAndWaitOnHealthyContainer(type: DockerWaitHealthyContainer) {
    dependsOn startContainer
    timeout = 75 // Dockerfile has "--interval=30s", so we give here a chance to check twice +15 sec overlap
    targetContainerId { createContainer.getContainerId() }
}

task stopContainer(type: DockerStopContainer) {
    targetContainerId { createContainer.getContainerId() }
}
